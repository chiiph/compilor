package Proyecto2;

import java_cup.runtime.*;
import java.io.*;
import java.lang.Exception;

action code
{:
/*
    TODO LIST Y COMENTARIOS
    probar comentarios
    
    mul abajo del unico throw exceptop
    agregar chequep que 
    si el tipo e2c es angulo entonces y el del e1s es distinto de angulo
    tirar error que diga
    que para que sea sea mixt
    el primero enteror
    y el segundo angulo

    tipos¶
        booleano¶
        entero¶
        angulo¶
        dibujo¶
        ¶
    declaracion implicita¶
    expresion = aritmetica/relacional, o definicion de dibujo¶
    parentizado¶
    no defs anidados¶
    no exprs mixtas¶
    case insensitive¶
    setcolor enteros¶
¶
chequeos de tipo¶
    +, - -> entero y entero¶
            angulo y angulo¶                                                                                                                                   
    *    -> entero y entero¶
            entero y angulo¶
            angulo y entero¶
    /    -> entero y entero¶
            angulo y entero¶
    rel  -> entero y entero¶
            angulo y angulo¶
    move -> entero o angulo¶
    draw -> entero o dibujo¶
    cond -> bool / entero¶
    repe -> entero¶

+ asignacion incompatible¶
+ 1 grama completa¶
+ 2 ident componentes lexicos¶
+ 3 dar def dir sin¶
+ 4 implementacion¶
  5 desc gral de la aplicacion¶
  explicacion de los metodos y estructuras aux¶
 */

    private SymbolTable table = new SymbolTable();
    OurDrawer ourDrawer = new OurDrawer();
    private int last_draw_id = 0;
:}

parser code
{:
    public static void main(String args[])
    {
        try {
            new parser(new Yylex(System.in)).parse();
        } catch (Exception e)   {
            System.err.println(e.getMessage());
            System.exit(1);
        }
    }
    public void syntax_error(java_cup.runtime.Symbol sym) {
        System.out.println("Error parsing at line " + (sym.left + 1));
        System.exit(1);
    }
:}

terminal EXIT, SCOLON, ASSIGNMENT, COMMA, CLEAR, SETCOLOR, IF, PAREN_OPEN, PAREN_CLOSE;
terminal ELSE, REPEAT, TIMES, DRAW, MOVE;
terminal CONDITIONAL_OR, CONDITIONAL_AND, EQUALS, NOT_EQUALS, LT, GT, LT_EQ, GT_EQ, ADD, SUB;
terminal MUL, DIV, NOT, DEF, ANGLE;
terminal Integer INT_LITERAL;
terminal String ID;

non terminal programa, sentencia;
non terminal String expression;
non terminal lista_sentencias;
non terminal String sentencia_dib;
non terminal String postfix_expression;
non terminal String lista_sentencias_dib;

precedence left ADD, SUB;
precedence left MUL, DIV;
precedence left CONDITIONAL_AND;
precedence left CONDITIONAL_OR;
precedence left GT, LT, GT_EQ, LT_EQ;
precedence left EQUALS, NOT_EQUALS;
precedence right ELSE;

programa ::=
    lista_sentencias SCOLON EXIT
    ;

lista_sentencias ::=
    sentencia
    | lista_sentencias SCOLON sentencia
    ;

sentencia ::=
    ID:id ASSIGNMENT expression:e
        {:
        OurSymbol es = table.get(e);

        int res = table.addVar(es.getType(), id, es.getValue());
        if (res == 1)
            table.setValue(id, es.getValue());
        else if (res == 2) {
            String errormessage = "Tipo incompatible, no se puede asignar un " +
                                  es.getType() +
                                  " a un " +
                                  table.get(id).getType();
            throw new Exception(errormessage);
        }
        :}
    | sentencia_dib:s
        {:
        ourDrawer.evaluate(s);
        :}
    | CLEAR
        {:
        ourDrawer.reset();
        :}
    | SETCOLOR expression:r COMMA expression:g COMMA expression:b
        {:
        OurSymbol res_r = table.get(r);
        OurSymbol res_g = table.get(g);
        OurSymbol res_b = table.get(b);

        if (!(res_r.getType().equals("int"))) { throw new Exception("El 1er argumento debe ser de tipo entero!"); }
        if (!(res_g.getType().equals("int"))) { throw new Exception("El 2do argumento debe ser de tipo entero!"); }
        if (!(res_b.getType().equals("int"))) { throw new Exception("El 3er argumento debe ser de tipo entero!"); }
        ourDrawer.setColor(res_r.getValue(), res_g.getValue(), res_b.getValue());
        :}
    | IF PAREN_OPEN expression:econd PAREN_CLOSE sentencia_dib:thene
        {:
        OurSymbol cond_sym = table.get(econd);
        int cond_val = table.get(econd).getValue();

        if (cond_sym.getType() == "int") {
            if (cond_val != 0) {
                ourDrawer.evaluate(thene);
            }
        }
        else {
            throw new Exception("Error! El tipo del resultado de la expresion condicional debe ser entero o booleano.");
        }
        :}
    | IF PAREN_OPEN expression:econd PAREN_CLOSE sentencia_dib:thene ELSE sentencia_dib:elsee
        {:
        OurSymbol cond_sym = table.get(econd);
        int condition = cond_sym.getValue();

        if (cond_sym.getType().equals("int")) {
            if (condition != 0) {
                ourDrawer.evaluate(thene);
            }
            else {
                ourDrawer.evaluate(elsee);
            }
        }
        else {
            throw new Exception("Error! El tipo del resultado de la expresion condicional debe ser entero o booleano.");
        }
        :}
    | REPEAT PAREN_OPEN expression:econd PAREN_CLOSE TIMES sentencia_dib:rbody
        {:
        OurSymbol cond_sym = table.get(econd);
        int i = 0, times = cond_sym.getValue();
        
        if (cond_sym.getType().equals("int")) {
            for (i = 0; i < times; i++) {
                ourDrawer.evaluate(rbody);
            }
        }
        else {
            throw new Exception("Error! El tipo del resultado de la expresion de repetición debe ser entero.");
        }
        :}
    ;

sentencia_dib ::=
    DRAW expression:e
        {:
        /*
        draw, int = avazar el cursor ang unidades
        draw, did = reproducir un dibujo almacenado
        */

        /* go see the eval method in the OurDrawer class. */
        OurSymbol res = table.get(e);
        if (res.getType() == "int") {
            RESULT = "draw," + res.getValue().toString();
        }
        else if (res.getType() == "draw_id") {
            RESULT = "draw_named," + res.getValue().toString();
        }
        else { 
            throw new Exception("Error! El tipo del argumento de DRAW debe ser o bien entero o bien dibujo.");
        }
        :}
    | MOVE expression:e
        {:
        /*
        move, int = avanzar el cursor ang unidades sin dibujar
        move, ang = rotar el cursor
        */

        OurSymbol res = table.get(e);
        if (res.getType() == "int") {
            RESULT = "move," + res.getValue().toString();
        }
        else if (res.getType() == "angle") {
            RESULT = "rotate," + res.getValue().toString();
        }
        else {
            throw new Exception("Error! El tipo del argumento de MOVE debe ser o bien entero o bien angulo.");
        }
        :}
    ;

expression ::=
    expression:e1 ADD expression:e2
        {:
        OurSymbol e1s = table.get(e1);
        OurSymbol e2s = table.get(e2);

        if (e1s.getType() != e2s.getType())
            throw new Exception("Error: los operandos de una suma deben ser del mismo tipo.");

        /* Este chequeo se haca despues porque ahora puedo asegurar que ambos
         * operandos son del mismo tipo, y puedo fijarme solo en el primero. 
         */
        if (!((e1s.getType() == "int") || (e1s.getType() == "angle")))
            throw new Exception("Error: los operandos de una suma deben ser o bien de tipo entero o bien de tipo angulo.");

        String type = e1s.getType();
        RESULT = table.addAnonymVar(type, e1s.getValue() + e2s.getValue());
        :}
    | expression:e1 SUB expression:e2
        {:
        OurSymbol e1s = table.get(e1);
        OurSymbol e2s = table.get(e2);

        if (e1s.getType() != e2s.getType())
            throw new Exception("Error: los operandos deben ser del mismo tipo.");
        if ((e1s.getType() != "int") || (e1s.getType() != "angle"))
            throw new Exception("Error: los operandos de una resta deben ser o bien de tipo entero o bien de tipo angulo.");

        String type = e1s.getType();
        RESULT = table.addAnonymVar(type, e1s.getValue() - e2s.getValue());
        :}
    | expression:e1 MUL expression:e2
        {:
        OurSymbol e1s = table.get(e1);
        OurSymbol e2s = table.get(e2);

        if ((e1s.getType() == e2s.getType()) && e1s.getType() == "angle")
            throw new Exception("Error: los operandos no pueden ser ambos de tipo angulo.");

        String type = "int";

        if (e1s.getType() == "angle" || e2s.getType() == "angle")
            type = "angle";

        RESULT = table.addAnonymVar(type, e1s.getValue() * e2s.getValue());
        :}
    | expression:e1 DIV expression:e2
        {:
        OurSymbol e1s = table.get(e1);
        OurSymbol e2s = table.get(e2);

        if ((e1s.getType() == e2s.getType()) && e1s.getType() == "angle")
           throw new Exception("Error: los operandos no pueden ser ambos de tipo angulo.");

        if ((e1s.getType() != e2s.getType()) && e1s.getType() != "angle")
           throw new Exception("Error: solo el primero de los operandos puede ser de tipo angulo.");

        String type = "int";

        if (e1s.getType() == "angle")
           type = "angle";

        RESULT = table.addAnonymVar(type, e1s.getValue()/e2s.getValue());
        :}
    | expression:e1 LT expression:e2
        {:
        OurSymbol e1s = table.get(e1);
        OurSymbol e2s = table.get(e2);

        if ((e1s.getType() == "draw_id") || (e2s.getType() == "draw_id"))
           throw new Exception("Error: ninguno de los operandos puede ser de tipo dibujo.");
        if (e1s.getType() != e2s.getType())
           throw new Exception("Error: los operandos deben ser del mismo tipo.");

        RESULT = table.addAnonymVar("int", (e1s.getValue() < e2s.getValue()) ? 1 : 0);
        :}
    | expression:e1 GT expression:e2
        {:
        OurSymbol e1s = table.get(e1);
        OurSymbol e2s = table.get(e2);

        if ((e1s.getType() == "draw_id") || (e2s.getType() == "draw_id"))
           throw new Exception("Error: ninguno de los operandos puede ser de tipo dibujo.");
        if (e1s.getType() != e2s.getType())
           throw new Exception("Error: los operandos deben ser del mismo tipo.");

        RESULT = table.addAnonymVar("int", (e1s.getValue() > e2s.getValue()) ? 1 : 0);
        :}
    | expression:e1 LT_EQ expression:e2
        {:
        OurSymbol e1s = table.get(e1);
        OurSymbol e2s = table.get(e2);

        if ((e1s.getType() == "draw_id") || (e2s.getType() == "draw_id"))
           throw new Exception("Error: ninguno de los operandos puede ser de tipo dibujo.");
        if (e1s.getType() != e2s.getType())
           throw new Exception("Error: los operandos deben ser del mismo tipo.");

        RESULT = table.addAnonymVar("int", (e1s.getValue() >= e2s.getValue()) ? 1 : 0);
        :}
    | expression:e1 GT_EQ expression:e2
        {:
        OurSymbol e1s = table.get(e1);
        OurSymbol e2s = table.get(e2);

        if ((e1s.getType() == "draw_id") || (e2s.getType() == "draw_id"))
           throw new Exception("Error: ninguno de los operandos puede ser de tipo dibujo.");
        if (e1s.getType() != e2s.getType())
           throw new Exception("Error: los operandos deben ser del mismo tipo.");

        RESULT = table.addAnonymVar("int", (e1s.getValue() <= e2s.getValue()) ? 1 : 0);
        :}
    | expression:e1 CONDITIONAL_AND expression:e2
        {:
        OurSymbol e1s = table.get(e1);
        OurSymbol e2s = table.get(e2);

        if ((e1s.getType() == "draw_id") || (e2s.getType() == "draw_id"))
           throw new Exception("Error: ninguno de los operandos puede ser de tipo dibujo.");
        if (e1s.getType() != e2s.getType())
           throw new Exception("Error: los operandos deben ser del mismo tipo.");
        if (e1s.getType() != "int")
           throw new Exception("Error: los operandos no pueden ser de tipo angle.");

        int val = 0;
        if ((e1s.getValue().intValue() != 0) && (e2s.getValue().intValue() != 0))
            val = 1;

        RESULT = table.addAnonymVar("int", val);
        :}
    | expression:e1 CONDITIONAL_OR expression:e2
        {:
        OurSymbol e1s = table.get(e1);
        OurSymbol e2s = table.get(e2);

        if ((e1s.getType() == "draw_id") || (e2s.getType() == "draw_id"))
           throw new Exception("Error: ninguno de los operandos puede ser de tipo dibujo.");
        if (e1s.getType() != e2s.getType())
           throw new Exception("Error: los operandos deben ser del mismo tipo.");
        if (e1s.getType() != "int")
           throw new Exception("Error: los operandos no pueden ser de tipo angle.");

        int val = 0;

        if (e1s.getValue().intValue() != 0 ||
           e2s.getValue().intValue() != 0)
            val = 1;

        RESULT = table.addAnonymVar("int", val);
        :}
    | expression:e1 EQUALS expression:e2
        {:
        OurSymbol e1s = table.get(e1);
        OurSymbol e2s = table.get(e2);

        if ((e1s.getType() == "draw_id") || (e2s.getType() == "draw_id"))
           throw new Exception("Error: ninguno de los operandos puede ser de tipo dibujo.");
        if (e1s.getType() != e2s.getType())
           throw new Exception("Error: los operandos deben ser del mismo tipo.");

        RESULT = table.addAnonymVar("int", (e1s.getValue().intValue() == e2s.getValue().intValue())?1:0);
        :}
    | expression:e1 NOT_EQUALS expression:e2
        {:
        OurSymbol e1s = table.get(e1);
        OurSymbol e2s = table.get(e2);

        if ((e1s.getType() == "draw_id") || (e2s.getType() == "draw_id"))
           throw new Exception("Error: ninguno de los operandos puede ser de tipo dibujo.");
        if (e1s.getType() != e2s.getType())
           throw new Exception("Error: los operandos deben ser del mismo tipo.");

        RESULT = table.addAnonymVar("int", (e1s.getValue().intValue() != e2s.getValue().intValue()) ? 1 : 0);
        :}
    | ADD expression:e1
        {:
        OurSymbol s = table.get(e1);
        RESULT = table.addAnonymVar(s.getType(), + s.getValue());
        :}
    | SUB expression:e1
        {:
        OurSymbol s = table.get(e1);
        RESULT = table.addAnonymVar(s.getType(), - s.getValue());
        :}
    | NOT expression:e1
        {:
        OurSymbol s = table.get(e1);
        Integer val = s.getValue();
        if (val == 0)
            RESULT = table.addAnonymVar(s.getType(), 1);
        else
            RESULT = table.addAnonymVar(s.getType(), 0);
        :}
    | PAREN_OPEN expression:e PAREN_CLOSE
        {:
        RESULT = e;
        :}
    | postfix_expression:pe
        {:
        RESULT = pe;
        :}
    ;

postfix_expression ::=
    ID:id
        {:
        if (table.isDeclared(id))
            RESULT = id;
        else
            throw new Exception("Variable no declarada: "+id);
        :}
    | INT_LITERAL:lit ANGLE
        {:
        RESULT = table.addAnonymVar("angle", lit);
        :}
    | INT_LITERAL:lit
        {:
        RESULT = table.addAnonymVar("int", lit);
        :}
    | DEF PAREN_OPEN lista_sentencias_dib:list PAREN_CLOSE
        {:
        ourDrawer.setNamedDraw(last_draw_id, list);
        RESULT = table.addAnonymVar("draw_id", last_draw_id++);
        :}
    ;

lista_sentencias_dib ::=
    sentencia_dib:s
        {:
        RESULT = s;
        :}
    | lista_sentencias_dib:list SCOLON sentencia_dib:s
        {:
        RESULT = list + ";" + s;
        :}
    ;
