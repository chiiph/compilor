string_code = ".data\n"
string_code += "CR_String: dw 0\n"
string_code += "VT_String: dw String_length,String_charAt,String_concat,String_equals\n"
string_code += ".code\n"
string_code += "String_length:\n"
string_code += "  loadfp\n"
string_code += "  loadsp\n"
string_code += "  storefp\n"
string_code += "	push 0 ; al principio la longitud es 0\n"
string_code += "	store 4 ; lo guardo en el ret_val\n"
string_code += "\n"
string_code += "prin_length:\n"
string_code += "	load 3 ; this\n"
string_code += "	load 4\n"
string_code += "  push 1\n"
string_code += "	add ; le sumo 1 al ret_val para saltear la vtable\n"
string_code += "  add ; le sumo la posicion actual\n"
string_code += "	deref ; accedemos al char\n"
string_code += "	bf fin_length ; si es \\0, ya esta\n"
string_code += "\n"
string_code += "	load 4 ; cargo la longitud hasta el momento\n"
string_code += "	push 1\n"
string_code += "	add\n"
string_code += "	store 4 ; le sumo 1\n"
string_code += "\n"
string_code += "	jump prin_length\n"
string_code += "fin_length: nop\n"
string_code += "  storefp\n"
string_code += "	ret 1\n"
string_code += "\n"
string_code += "String_charAt:\n"
string_code += "  loadfp\n"
string_code += "  loadsp\n"
string_code += "  storefp\n"
string_code += "	push 0\n"
string_code += "	store 5 ; por default, el charAt actual es \\0\n"
string_code += "\n"
string_code += "	load 4 ; cargo el indice pedido\n"
string_code += "	rmem 1\n"
string_code += "	load 3\n"
string_code += "	push String_length\n"
string_code += "	call ; calculo la longitud\n"
string_code += "	lt ; menor estricto, poruqe sino pide el char \\0\n"
string_code += "	bf fin_charAt ; si no es menor o igual, no hay nada para hacer\n"
string_code += "\n"
string_code += "  load 3\n"
string_code += "	push 1\n"
string_code += "	add ; salteo la vtable\n"
string_code += "	load 4\n"
string_code += "	add ; le sumo 1\n"
string_code += "	deref\n"
string_code += "\n"
string_code += "	store 5 ; guardo el char actual como restulado\n"
string_code += "	fin_charAt:\n"
string_code += "  storefp\n"
string_code += "	ret 2\n"
string_code += "\n"
string_code += "String_concat:\n"
string_code += "  loadfp\n"
string_code += "  loadsp\n"
string_code += "  storefp\n"
string_code += "	rmem 2 ; reservo una variable temporal para guardar la posicion actual\n"
string_code += "	       ; una para el offset actual y otra para el offset en el string final\n"
string_code += "	push 1\n"
string_code += "	store 0\n"
string_code += "	push 1\n"
string_code += "	store -1 ; inicializo ambos en 1, en 0 esta la vtable\n"
string_code += "\n"
string_code += "	rmem 1 ; este es para el simple_malloc de mas abajo\n"
string_code += "  rmem 1\n"
string_code += "	load 3\n"
string_code += "	push String_length\n"
string_code += "	call\n"
string_code += "	rmem 1\n"
string_code += "	load 4\n"
string_code += "	push String_length\n"
string_code += "	call ; calculo los lengths\n"
string_code += "	add ; los sumo para obtener el length final\n"
string_code += "	push 2 ; vtable y \\0\n"
string_code += "	add\n"
string_code += "	push simple_malloc\n"
string_code += "	call ; alloc de la memoria necesaria\n"
string_code += "  dup\n"
string_code += "	store 5 ; guardo el puntero en el ret_val\n"
string_code += "  push VT_String\n"
string_code += "  storeref 0\n"
string_code += "\n"
string_code += "prin_concat1:\n"
string_code += "	load 3 ; this\n"
string_code += "	load 0\n"
string_code += "	add ; le sumo la posicion actual\n"
string_code += "	deref\n"
string_code += "	dup ; duplico, porque el bf lo vuela de la pila sino\n"
string_code += "	bf fin_concat1 ; si es \\0, ya esta\n"
string_code += "\n"
string_code += "	; en el tope de la pila tengo el char actual\n"
string_code += "	load 5 ; cargo el puntero al string final\n"
string_code += "	load -1 ; cargo la posicion actual en el\n"
string_code += "	add\nswap\n"
string_code += "	storeref 0 ; guardo en la posicion 0 porque ya se sumo el offset\n"
string_code += "\n"
string_code += "	load 0\n"
string_code += "	push 1\n"
string_code += "	add ; le sumo 1 a la posicion actual\n"
string_code += "	store 0\n"
string_code += "\n"
string_code += "  load -1\n"
string_code += "  push 1\n"
string_code += "  add ; idem\n"
string_code += "  store -1\n"
string_code += "\n"
string_code += "	jump prin_concat1\n"
string_code += "fin_concat1: nop\n"
string_code += "\n"
string_code += "  push 1\n"
string_code += "  store 0 ; reseteamos el char actual para el segundo string\n"
string_code += "\n"
string_code += "prin_concat2:\n"
string_code += "	load 4 ; el otro string\n"
string_code += "	load 0\n"
string_code += "	add ; le sumo la posicion actual\n"
string_code += "	deref\n"
string_code += "	dup ; duplico, porque el bf lo vuela de la pila sino\n"
string_code += "	bf fin_concat2 ; si es \\0, ya esta\n"
string_code += "\n"
string_code += "	; en el tope de la pila tengo el char actual\n"
string_code += "	load 5 ; cargo el puntero al string final\n"
string_code += "	load -1 ; cargo la posicion actual en el\n"
string_code += "	add\nswap\n"
string_code += "	storeref 0 ; guardo en la posicion 0 porque ya se sumo el offset\n"
string_code += "\n"
string_code += "	load 0\n"
string_code += "	push 1\n"
string_code += "	add ; le sumo 1 a la posicion actual\n"
string_code += "	store 0\n"
string_code += "\n"
string_code += "  load -1\n"
string_code += "  push 1\n"
string_code += "  add\n"
string_code += "  store -1\n"
string_code += "\n"
string_code += "	jump prin_concat2\n"
string_code += "fin_concat2: nop\n"
string_code += "\n"
string_code += "  load 5\n"
string_code += "  load -1\n"
string_code += "  add\n"
string_code += "  push 0\n"
string_code += "  storeref 0 ; finalizamos el string\n"
string_code += "\n"
string_code += "	fmem 2\n"
string_code += "pop\npop ; algo me estoy olvidando, pero estos pops tienen que estar\n"
string_code += "  storefp\n"
string_code += "  ret 2\n"
string_code += "\n"
string_code += "String_equals:\n"
string_code += "  loadfp\n"
string_code += "  loadsp\n"
string_code += "  storefp\n"
string_code += "  rmem 1 ; var tmp para posicion\n"
string_code += "  push 1\n"
string_code += "  store 0\n"
string_code += "\n"
string_code += "	push 0\n"
string_code += "	store 5 ; por default es false\n"
string_code += "\n"
string_code += "  rmem 1\n"
string_code += "	load 3\n"
string_code += "	push String_length\n"
string_code += "	call ; calculo la longitud\n"
string_code += "  rmem 1\n"
string_code += "	load 4 ; cargo el indice pedido\n"
string_code += "  push String_length\n"
string_code += "  call\n"
string_code += "	eq\n"
string_code += "	bf fin_equals ; si no es igual de longitud, no hay nada para hacer\n"
string_code += "\n"
string_code += "prin_equals:\n"
string_code += "  load 3\n"
string_code += "  load 0\n"
string_code += "  add\n"
string_code += "  deref ; cargo el char actual del primer string\n"
string_code += "  load 4\n"
string_code += "  load 0\n"
string_code += "  add\n"
string_code += "  deref ; cargo el otro\n"
string_code += "\n"
string_code += "  dup ; caso especial, es \\0?\n"
string_code += "  bf fin_equals_true\n"
string_code += "\n"
string_code += "  eq ; sino, si son iguales\n"
string_code += "  load 0\n"
string_code += "  push 1\n"
string_code += "  add\n"
string_code += "  store 0\n"
string_code += "  bt prin_equals ; vamos al qeu sigue\n"
string_code += "  jump fin_equals\n"
string_code += "\n"
string_code += "fin_equals_true:\n"
string_code += "  pop\npop ; y otra vez el mismo tema\n"
string_code += "  push 1\n"
string_code += "  store 5 ; pongo el ret_val en true\n"
string_code += "\n"
string_code += "fin_equals:\n"
string_code += "  fmem 1\n"
string_code += "  storefp\n"
string_code += "  ret 2\n"
string_code += "\n"
