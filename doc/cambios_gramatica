La gramática fue procesada de manera tal que fuera LL(1). Para lograr
esto primero se eliminó la recursividad a izquierda y luego se
factorizó.
Dado que la gramática original no está diseñada para que sea procesada
como una LL(1), hubo que realizar algunas excepciones que se trataran
en las etapas siguientes:

1. En la gramática original se diferencia entre declaración de
constructor y declaración de métodos. Esto sucede porque los
constructores no deben llevar un tipo de retorno. Pero dado que el
tipo de retorno puede ser un token reconocido como IDENTIFIER, se
resolvió tratar a todos los métodos por igual, y dejar el checkeo de
tipo de retorno según el tipo de método para la etapa del análisis
semántico.

2. De forma similar a 1., los tipos de los atributos de clase tienen
un caso especial: no pueden ser de tipo VOID_TYPE. Esto dificulta la
gramática resultante, por lo que se resolvió realizar el checkeo de
que los atributos de clase no pueden ser de tipo VOID_TYPE en la etapa
de análisis semántico.

3. Otro caso especial ocurre con los constructores, que no pueden
poseer el token STATIC en sus modificadores. Como se dijo en 1., se
tratarán a los constructores como métodos regulares y el checkeo de
que no estén declarados como static se hará en la etapa de análisis
semántico.

4. La regla de la gramática original que cuyo lado izquierdo era
<expression> contenia una ambiguedad que no es posible resolver desde
el punto de vista sintáctico. Esta ambiguedad se debe a la similitud
posible entre una sentencia de asignación y una expresión condicional,
por lo que se resolvió mover la detección de la asignación más
adelante en el arbol sintáctico. Esto da lugar a que sea posible
escribir sentencias del estilo: (a + 4) = 2;
   Este control se realizará en la etapa de análisis semántico.

5. El último cambio significativo a la gramática corresponde a las
sentecias de control, específicamente al if. Para resolver
ambiguedades en una cadena de ifs anidados con sus respectivos else,
la gramática utiliza una serie de reglas que a la hora de convertir a
LL(1) resulta imposible. Para saltear esta barrera, se simplificaron
las reglas en cuestión, y se asume que cada else está ligado al if más
cercano.
   Esta consideración recién se verá en la etapa de generación de
código.